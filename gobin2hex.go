package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"go/token"
	"log"
	"os"
	"unicode"
)

func main() {
	log.SetFlags(0)
	log.SetPrefix("gobin2hex: ")
	flag.Usage = usage
	flag.Parse()
	if flag.NArg() < 1 {
		flag.Usage()
	}

	name := flag.Arg(0)
	if !isIdent(name) {
		log.Fatalf("invalid identifier %q", name)
	}

	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "// automatically generated by gobin2hex\n")
	fmt.Fprintf(buf, "var %s = []uint8{\n\t", name)
	i := uint64(0)
	for {
		var b [8192]byte
		n, err := os.Stdin.Read(b[:])
		for j := 0; j < n; j++ {
			if i != 0 && i%10 == 0 {
				fmt.Fprintf(buf, "\n\t")
			}
			i++
			fmt.Fprintf(buf, "%#02x,", b[j])
		}
		if err != nil {
			break
		}
	}
	fmt.Fprintf(buf, "\n}")

	src, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("Source:\n%s\n", buf.Bytes())
		fmt.Printf("\n")
		panic(err)
	}
	fmt.Printf("%s\n", src)
}

func usage() {
	fmt.Fprintln(os.Stderr, "usage: firmware")
	flag.PrintDefaults()
	os.Exit(2)
}

func isIdent(ident string) bool {
	tok := token.Lookup(ident)
	if tok != token.IDENT {
		return false
	}

	for i, ch := range ident {
		switch {
		case i == 0 && !unicode.IsLetter(ch):
			return false
		case i > 0 && !(unicode.IsLetter(ch) || unicode.IsNumber(ch) || ch == '_'):
			return false
		}
	}
	return true
}
