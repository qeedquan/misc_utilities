/*

https://en.wikipedia.org/wiki/Covariance_and_contravariance_of_vectors
https://en.wikipedia.org/wiki/Dual_basis
https://en.wikipedia.org/wiki/Einstein_notation#Vector_representations
https://en.wikipedia.org/wiki/Raising_and_lowering_indices
https://www.mathpages.com/home/kmath398/kmath398.htm
https://mathworld.wolfram.com/Tensor.html
https://my.mech.utah.edu/~brannon/public/curvilinear.pdf

*/

PVector[] basis;
PVector vector;
int fontsz;

void setup() {
  size(1200, 800);
  fontsz = 16;
  textSize(fontsz);
  
  basis = new PVector[]{
    new PVector(50, 0),
    new PVector(0, -50),
  };
  vector = new PVector(100, 100);
}

void draw() {
  PMatrix2D B = orientation(basis);
  PMatrix2D BI = B.get();
  BI.invert();

  PVector[] dual = duals(basis);
  PMatrix2D D = orientation(dual);
  PMatrix2D DI = D.get();
  DI.invert();
  
  PVector ct = BI.mult(vector, null);
  PVector cv = DI.mult(vector, null);
  
  PVector v1 = B.mult(ct, null);
  PVector v2 = D.mult(cv, null);
  
  background(120);
  fill(200);
  drawBasis(basis);

  fill(60, 70, 80);
  arrow(width/2, height/2, width/2+vector.x, height/2+vector.y, 10);

  fill(255);
  text(String.format("Basis: [[%.3f %.3f] [%.3f %.3f]] Inverse: [[%.3f %.3f] [%.3f %.3f]]",
       basis[0].x, basis[0].y, basis[1].x, basis[1].y, BI.m00, BI.m01, BI.m10, BI.m11), 16, 25 + 0*fontsz);
  text(String.format("Dual Basis: [[%.3f %.3f] [%.3f %.3f]] Inverse: [[%.3f %.3f] [%.3f %.3f]]",
       dual[0].x, dual[0].y, dual[1].x, dual[1].y, DI.m00, DI.m01, DI.m10, DI.m11), 16, 25 + 1*fontsz);
  text(String.format("Contravariant Components: [%.3f %.3f]", ct.x, ct.y), 16, 25 + 2*fontsz);
  text(String.format("Covariant Components: [%.3f %.3f]", cv.x, cv.y), 16, 25 + 3*fontsz);
  text(String.format("Vector: [%.3f %.3f]", vector.x, vector.y), 16, 25 + 4*fontsz);
  text(String.format("Vector Representation: [%.3f %.3f] [%.3f %.3f]", v1.x, v1.y, v2.x, v2.y), 16, 25 + 5*fontsz);
  text(String.format("Basis Constraint: [%.3f %.3f] [%.3f %.3f]",
       basis[0].dot(dual[0]), basis[0].dot(dual[1]), basis[1].dot(dual[0]), basis[1].dot(dual[1])), 16, 25 + 6*fontsz);
}

void mousePressed() {
  float x = mouseX - width/2;
  float y = mouseY - height/2;
  
  if (keyPressed && keyCode == SHIFT) {
    if (mouseButton == LEFT)
      basis[0].set(x, y);
    else if (mouseButton == RIGHT)
      basis[1].set(x, y);
  } else if (mouseButton == LEFT)
    vector.set(x, y);
}

void drawBasis(PVector[] b) {
  float x = width/2;
  float y = height/2;
  float tz = 10;
  fill(100, 50, 80);
  arrow(x, y, x+b[0].x, y+b[0].y, tz);
  fill(70, 100, 200);
  arrow(x, y, x+b[1].x, y+b[1].y, tz);
}

void arrow(float x1, float y1, float x2, float y2, float tz) {
  line(x1, y1, x2, y2);
  
  float ang = atan2(y2-y1, x2-x1) + radians(270);
  pushMatrix();
  translate(x2, y2);
  rotate(ang);
  triangle(-tz, 0, tz, 0, 0, tz);
  popMatrix();
}

PMatrix2D orientation(PVector[] b) {
  return new PMatrix2D(b[0].x, b[1].x, 0, b[0].y, b[1].y, 0);
}

/*

When we are transforming vectors, their components change with the basis and if we make a basis change,
the components will also be scaled accordingly. However the vector we want to represent should stay the same.

This means the vector can be represented in different bases as follows:
v = v_1*e_1 + v_2*e_2 ... + v_n*e_n (covector, where its covariant components scale with the basis)
v = v^1*e^1 + v^2*e^2 ... + v^n*e^n (vector, where its contravariant components scale inversely with the basis)

We want to understand how the components v_i and v^i changes when we change the basis,
this can be analyzed using the concept of a dual basis.

A dual basis can be computed using the following rules:

(Einstein notation, the 'i' represents indices and not a power)
e^i = contravariant basis (upper index)
e_i = covariant basis     (lower index)

e^i: tangent vectors, position vectors, vectors
e_i: gradient of scalar field, normal vectors, covectors

dot(e^i, e_j) = 1 if i = j
The basis vector e^i does not have to be the same vector as e_i in this case, but they have to
scale with the original basis vector in such a way that the dot product is normalized

dot(e^i, e_j) = 0 if i != j
The basis vector e^i is orthogonal to every other basis vector in the original basis set.

We can view this as generating a identity matrix if for every index entry
Aij = dot(e^i, e_j)

For orthonormal basis in euclidean space, we can show that the constraint above makes the
contravariant and covariant basis vectors the same, ie, the basis vectors are generated by unit rotation matrices.
This is not true in general spaces however.

The distinction becomes important if we are in a curvilinear or even a euclidean space where
the basis vectors are not orthogonal to each other or not unit length.

In Euclidean space, we can show that the dual basis is the inverse transpose of the orientation matrix we make
with the original basis vectors.

Tensors are used to keep track of this contravariant/covariant distinction and unifies the operations (dot, cross, gradients)
in such a way that if we apply the valid tensor operations in one coordinate system and transform it to another, it gives the
same answer as if if we did the operation in the other coordinate system directly. The invariance here is the sum of the
components times the base vectors are invariant even though the components themselves or base vectors cane change under
the coordinate transformation.

Some Einstein notation:
Index raising/lowering: Converts v_i to v^i and v^i to v_i respectively, using the metric tensor.
g^(ij)*a_v = a^u
g_(ij)*a^v = a_i

All of this is in orthonormal basis (where covectors are equal to vectors):
Dot product:
u . v = u_j*v^j

Cross product:
u x v = Îµ^i_jk * u^j * v^k * e_i

*/

PVector[] duals(PVector[] b) {
  PVector d1 = new PVector(-b[1].y, b[1].x);
  PVector d2 = new PVector(-b[0].y, b[0].x);

  float l1 = b[0].dot(d1);
  float l2 = b[1].dot(d2);
  d1.mult(1.0/l1);
  d2.mult(1.0/l2);

  return new PVector[]{d1, d2};
}
