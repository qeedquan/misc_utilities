*** Folder Structure

Top level is vxworks folder

samples -> sample code/projects to build
    vip_itl_generic -> VIP image for generic Intel board
        default -> build directory output

pkgs_v2 -> all the system source code goes in this folder
    os/board                  -> contains all the BSP code (code used for VIP generation)
    os/utils.x.x.x.x/bootapp  -> contains the bootapp code

*** VSB
The VSB contains all the libraries to be linked by the VIP.
Multiple VIPs can use one VSB. When building VSB it builds all of the vxworks code into static libraries
and then generate C code that is callable by the VIP to init, this is stored inside configlette code.

These configlette code are obtained from cfg/ folder for every module to initialize it

Every module will have the following structure:
cfg/ -> code to initialize the module, will be copied into the VSB/VIP for building and executing.
cdf/ -> definitions on how to build the module
src/ -> the implementation itself
h/ -> header files
layer.vsbl -> file to describe the layer

If a layer has dependencies that are not met, adding a layer without meeting the dependencies will make the build system skip copying cdfs and compiling any configlettes in.

*** Prebuilt VSB
There are prebuilt VSBs shipped with VxWorks inside samples/prebuilt_projects which includes a VxSim build.

*** Profiles
Profiles are a way to share a custom configured VSB/VIP.
They are generated files that contain all the configuration of the custom VSB/VIP that the vxprj tool can import to build.

To create a profile given a built VSB:

vxprj vsb createProfile -vsb <wpjfile> -name <profile_name_output>

If you don't have a workspace project file, you can just specify the vsb directory:

vxprj vsb createProfile -vsb <vsb_directory> -name <profile_name_output>

By default, VxWorks provides a directory inside vip_profiles/profiles that you can place the custom VIP profiles in.
Then when building the VIP, it will show up in the profile list to select and use to build

To create a profile given a built VIP:
vxprj vip createProfile -vip <vip_dir> -name <profile_name_output>

This generates a profile inside vip_profiles/profiles

Profiles can use environment variables and will expand them when building
Example:
export FOO=/path/to/foo
Inside the profile we can use $(FOO)/xyz

*** Defines
_WRS_KERNEL
    code executing inside the kernel space as opposed to user space (RTPs)

_WRS_CONFIG_SMP
    whether or not the system is compile for smp

_WRS_CONFIG_LP64
    64 bit model

_WRS_CONFIG_DEBUG_FLAG
    Whether or not to output debugging output.
    For device initialization, it will dump all the scanning for device output, useful for seeing which device gets scanned and initialized on startup.
    For networking, all the information about networking errors get outputted to syslog (ssh, sftp, etc)

Defines are passed to VSB to enable/disable options, if a configuration has a dependency, the build tool will silently skip the configuration if the dependency is not met.
The build tools add dependencies in a left to right argument order, so any configuration dependencies has to be specified before the dependency.

*** Entry Point
Entry point is sysALib.s which is inside the BSP folder per board.

entry (sysALib.s) ->
usrInit() (Autogenerated C code when VIP is made, it is inside the prjConfig.c file)

*** vxprj commands
vxprj vsb listBsps     - lists all the BSPs supported to be built
vxprj vsb listAll      - list all layers
vxprj vsb listProfiles - list all profiles

vxprj vsb profileInfo <profileName> - list info about a profile 

vxprj vsb create -bsp <bsp_name> <output_dir> - create a BSP project, the <bsp_name> comes from listBsps, if no output_dir is specified then it creates it in the workspace

vxprj build       - build the project
vxprj build clean - clean build

vxprj bundle list /path/to/vip_directory/ all - list all supported bundles that is addible to the vip project

vxprj vsb build <layer>          - rebuild a single VSB layer
make __LAYERS_TO_BUILD = "layer" - alternative way to rebuild a single layer

vxprj vsb build VXBUS - rebuild the vxbus layer

vxprj vip file add <file>           - adds a file to the build
vxprj vip component add <component> - adds a component
vxprj vip bundle add <bundle>       - adds a bundle

vxprj vip parameter set <parameter> <value> - sets a parameter, regenerates prjConfig.c whenever this happens

vxprj vip profile list -vsb <directory_to_valid_vsb> -
lists the profile a VSB supports for building, profiles are defined within the VSB.
the VSB has to be built first before the profiles are generated.

vxprj vsb config -w -add '_WRS_CONFIG_ADVANCED_OPT=y'
vxprj vsb config -w -add '_WRS_CONFIG_ADDEDCFLAGS=-Dfoo=bar'
Adds a custom define to the VSB project

vxprj vip buildmacro set ADDED_CFLAGS '-Dfoo=bar -I/path'
Adds a custom define/include path to the VIP project

vxprj vip buildmacro set EXTRA_MODULES '/path/to/foo.o'
Adds custom .o file (not .out) files to link against the kernel image, this allows for binary object files to be linked against the kernel image

To build .o files, pass the -c flag in wr-cc
DKM .out files will not work since it has been pre-linked with various kernel libraries that will have symbols conflict

If the DKM code has VXB_DRV_DEF(), it will add a special symbol into the .data section that causes the the DKM to get loaded automatically in the kernel when the .o file gets linked in
Since this is directly linked into the kernel, it won't show up in moduleShow since it was not loaded dynamically

*** Parameters

These parameters are mainly when bootrom is used
ROM_TEXT_ADRS - Where the ROM code starts on bootup (ROM code is the firmware of the system and runs before the VxWorks image is loaded)
RAM_HIGH_ADRS - Bootrom gets loaded here, then the bootrom can be used to load VxWorks or something else
RAM_LOW_ADRS  - Where VxWorks image gets loaded by the bootrom, (RAM_HIGH_ADRS-RAM_LOW_ADRS) should be big enough to fit the VxWorks image
LOCAL_MEM_LOCAL_ADRS - Start address of main memory
MEM_POOL_START/MEM_POOL_END - Location where memory pools are allocated into, these are set by finding the first free RAM block and setting it to be just after the kernel location in RAM (plus some other params)

KERNEL_PROXIMITY_HEAP_SIZE - Kernel pool size at early init, this memory location is usually used for MMU data structures (page tables), setting this too small can make MMU initialization fail

RAM is assumed to be between LOCAL_MEM_LOCAL_ADRS and sysPhysMemTop
The space between LOCAL_MEM_LOCAL_ADRS and FREE_MEM_START_ADRS is the kernel code and pools

Stack sizes, each arch will have different settings for them (defined in arch/)
The stack sizes are usually 8kb to 64kb
ROOT_STACK_SIZE - Root task task size
SHELL_STACK_SIZE - Shell stack size
ISR_STACK_SIZE - ISR stack size
KERNEL_TASK_EXC_STACK_SIZE - Task execution stack size

*** CPU Arches
CPU Arches are defined inside archcpu.cdf
The compiler flags for the CPU arches are defined in utils/wrcc/src/conf/cpu

To add new arches, modify the CDF and then add compilation options for it to wr-cc

The wrcc configuration also stores the location of the RTP base addresses when compiling

*** Workbench vs Command Line Tools
Workbench might not detect new cdf added to the system while the command line tools can
Need to add the component in the cdf to the 00folder_*.cdf to make it visible

*** Portable core functions
By default VxWorks tries to use assembly implementations of various core functions, to use the portable version, define PORTABLE=1 when building the VSB
vxprj vsb config -add "_WRS_CONFIG_ADDEDCFLAGS=-DPORTABLE=1" -s

*** RPMs

# Install RPMs
$WIND_HOME/maintenance/wrInstaller/x86-linux2/wrInstaller -silent -nosplash -installerUpdateURLS none -yum -y localinstall *.rpm

# Remove RPMs
$WIND_HOME/maintenance/wrInstaller/x86-linux2/wrInstaller -silent -nosplash -installerUpdateURLS none -yum -y remove *.rpm

*** 3rd party packages

If the package doesn't exist, by default the build tools will try to wget it from the predefined URL (usually from the internet)
Place the downloaded files into:
$WIND_HOME/download (older versions like sr630)
$WIND_HOME/3pp-download (newer versions)
for the build tools to see and use it (without downloading it)

$WIND_3PP_PATH is the environment variable specifying the location

*** Autotools
wr-cc/wr-c++/wr-ld/etc are wrappers around clang/gcc toolchain, they can just work with autotools for the most part.
Need to specify the host to autotools for it to use the wr-* wrappers.
By default, wr-cc/wr-c++ outputs RTPs when the -o option is used (-rtp is enabled implicitly).

wr-ld is different from the standard ld, it emits different number of segments/etc.
In order to generate .so files that can be run in VxWorks, need to use wr-ld.

