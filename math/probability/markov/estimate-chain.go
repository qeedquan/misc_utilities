/*

https://www.eecis.udel.edu/~lliao/cis841s06/hmmtutorialpart1.pdf

*/

package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())

	test([][]float64{
		{0.25, 0.5, 0.25},
		{0.3, 0.4, 0.3},
		{0.3, 0.5, 0.2},
	}, []float64{0.2, 0.6, 0.2})

	for i := 0; i < 10; i++ {
		for j := 2; j < 8; j++ {
			P, x := stochastic(j)
			test(P, x)
		}
	}
}

func test(P [][]float64, x []float64) {
	Q, y, _ := estimate(P, x, 1e5)
	fmt.Println(x)
	fmt.Println(y)
	fmt.Println()
	dump(P)
	dump(Q)
}

/*

Given a markov chain generated by transition matrix P and initial state vector x, we want to recover P and x only looking at it's output.

One way is to recover it is to count the frequencies of the state it outputs and divide by the total number of outcomes to get an estimate.
As we get more samples, the estimate should get better.

For steady state chains, the transition matrix can be recovered closely, but not the initial state vector since it gets drowned out by the steady state behavior.

*/
func estimate(P [][]float64, x []float64, n int) (Q [][]float64, y []float64, l int) {
	m := len(x)
	Q = alloc(m, m)
	y = make([]float64, m)

	u := choose(x)
	for ; l < n; l++ {
		v := choose(P[u])
		Q[u][v], y[u], u = Q[u][v]+1, y[u]+1, v
	}

	for i := range y {
		y[i] /= float64(l)
	}

	for i := range Q {
		t := 0.0
		for j := range Q[i] {
			t += Q[i][j]
		}
		for j := range Q[i] {
			Q[i][j] /= t
		}
	}

	return
}

func choose(p []float64) int {
	x := rand.Float64()
	for i, y := range p {
		if x <= y {
			return i
		}
		x -= y
	}
	return 0
}

func alloc(r, c int) [][]float64 {
	m := make([][]float64, r)
	t := make([]float64, r*c)
	for i := range m {
		m[i] = t[i*c : (i+1)*c]
	}
	return m
}

func stochastic(n int) (m [][]float64, x []float64) {
	m = alloc(n, n)
	x = make([]float64, n)

	for i := range m {
		t := 0.0
		for j := range m[i] {
			m[i][j] = rand.Float64()
			t += m[i][j]
		}

		for j := range m[i] {
			m[i][j] /= t
		}
	}

	t := 0.0
	for i := range x {
		x[i] = rand.Float64()
		t += x[i]
	}
	for i := range x {
		x[i] /= t
	}

	return
}

func dump(m [][]float64) {
	for i := range m {
		for j := range m[i] {
			fmt.Printf("% .6f ", m[i][j])
		}
		fmt.Println()
	}
	fmt.Println()
}
