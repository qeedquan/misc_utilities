/*

https://en.wikipedia.org/wiki/Hypercomplex_number
https://en.wikipedia.org/wiki/Split-complex_number
https://en.wikipedia.org/wiki/Dual_number
https://en.wikipedia.org/wiki/Imaginary_number
https://en.wikipedia.org/wiki/Complex_conjugate
https://math.ucr.edu/home/baez/diary/october_2019.html

*/

package main

import "fmt"

func main() {
	test_properties(-1)
	test_properties(0)
	test_properties(1)
}

/*

Hypercomplex numbers extend complex numbers by redefining what i^2 means

i^2 = -1 gives the usual complex numbers
i^2 = 0 gives the dual numbers
i^2 = 1 gives the split-complex numbers

There is a theorem that says that the 3 unital algebras above are all we can make in 2D up to an isomorphism
i^2 = c can be represented by a scaling of the above

Most of the operations are the same as the complex numbers, some operations differ however

Multiplication:
(a+bi)(c+di) = ac + adi + bci + bdi^2
i^2 = -1 -> (ac-bd) + (ad+bc)i (circular rotation)
i^2 = 0  ->  ac     + (ad+bc)i (galilean transform or vertical shear mapping)
i^2 = 1  -> (ac+bd) + (ad+bc)i (hyperbolic rotation)

Modulus Squared:
v = (a+bi)
|v|^2 = v * conj(v)
i^2 = -1 -> x^2 + y^2 (circle)
i^2 = 0  -> x^2       (parallel lines)
i^2 = 1  -> x^2 - y^2 (hyperbola)

We can represent these in matrix form
i^2 = -1 -> [[a -b] [b a]]
i^2 = 0  -> [[a b] [0 a]]
i^2 = 1  -> [[a b] [b a]]

The unit circle represents the |a+bi| = 1
It can be generated using the complex exponential e^(it)

If we graph sin/cos using the series expansion of e^(it) with i^2=c, we can see a circle slowly
morph into a line (-1 -> 0) then slowly morphs into a hyperbola (0 -> 1)

i^2 = -1 -> x^2 + y^1 = 1 so it is generated by <cos(t), sin(t)>
i^2 = 0  -> x^2 = 1       so it is generated by <+-1, t>
i^2 = -1 -> x^2 - y^2 = 1 so it is generated by <cosh(t), sinh(t)>

*/

func test_properties(e int) {
	fmt.Println("Testing properties of i^2 =", e)

	// 1+0i gives rise to the identity matrix
	fmt.Println("Matrix of identity element")
	fmt.Println(hcm(hypercomplex{1, 0, e}))

	a := hypercomplex{2, 6, e}
	b := hypercomplex{7, 12, e}
	A := hcm(a)
	B := hcm(b)
	fmt.Printf("a=%v b=%v\n", a, b)
	fmt.Println(A)
	fmt.Println(B)

	fmt.Println("a+b | A+B")
	fmt.Println(add(a, b))
	fmt.Println(add2(A, B))
	fmt.Println()

	fmt.Println("a-b | A-B")
	fmt.Println(sub(a, b))
	fmt.Println(sub2(A, B))
	fmt.Println()

	fmt.Println("a*b | A*B")
	fmt.Println(mul(a, b))
	fmt.Println(mul2(A, B))
	fmt.Println()

	fmt.Println("a/b | A*B^-1")
	fmt.Println(div(a, b))
	fmt.Println(mul2(A, inv2(B)))

	fmt.Println("|a|^2 |b|^2 | det(A) det(B)")
	fmt.Println(modulus(a), modulus(b))
	fmt.Println(det2(A), det2(B))
	fmt.Println()

	// for complex numbers we can also take the transpose
	// but the transpose does not generalize
	fmt.Println("conj(a) conj(b) | adjugate(A) adjugate(B)")
	fmt.Println(conj(a), conj(b))
	fmt.Println(adj2(A))
	fmt.Println(adj2(B))
	fmt.Println()

	fmt.Println("a*conj(a) b*conj(b) | A*adjugate(A) B*adjugate(B)")
	fmt.Println(mul(a, conj(a)), mul(b, conj(b)))
	fmt.Println(mul2(A, adj2(A)))
	fmt.Println(mul2(B, adj2(B)))
	fmt.Println()
}

func assert(x bool) {
	if !x {
		panic("assertion failed")
	}
}

func abs(x int) int {
	if x < 0 {
		x = -x
	}
	return x
}

func gez(x int) int {
	if x >= 0 {
		return 1
	}
	return -1
}

type hypercomplex struct {
	r, i float64
	e    int
}

func (p hypercomplex) String() string {
	return fmt.Sprintf("(%.3f%+.3fi)", p.r, p.i)
}

func hcm(a hypercomplex) mat2 {
	return mat2{
		{a.r, a.i * float64(gez(a.e))},
		{a.i * float64(abs(a.e)), a.r},
	}
}

func add(a, b hypercomplex) hypercomplex {
	assert(a.e == b.e)
	return hypercomplex{a.r + b.r, a.i + b.i, a.e}
}

func sub(a, b hypercomplex) hypercomplex {
	assert(a.e == b.e)
	return hypercomplex{a.r - b.r, a.i - b.i, a.e}
}

func scale(a hypercomplex, s float64) hypercomplex {
	return hypercomplex{a.r * s, a.i * s, a.e}
}

func conj(a hypercomplex) hypercomplex {
	return hypercomplex{a.r, -a.i, a.e}
}

func mul(a, b hypercomplex) hypercomplex {
	assert(a.e == b.e)
	return hypercomplex{
		a.r*b.r + a.i*b.i*float64(a.e),
		a.r*b.i + a.i*b.r,
		a.e,
	}
}

func div(a, b hypercomplex) hypercomplex {
	assert(a.e == b.e)
	z := conj(b)
	x := mul(a, z)
	y := mul(b, z)
	return hypercomplex{
		x.r / y.r,
		x.i / y.r,
		a.e,
	}
}

func modulus(a hypercomplex) float64 {
	return a.r*a.r - a.i*a.i*float64(a.e)
}

type mat2 [2][2]float64

func (m mat2) String() string {
	return fmt.Sprintf("[%.3f %.3f]\n[%.3f %.3f]\n",
		m[0][0], m[0][1], m[1][0], m[1][1])
}

func add2(a, b mat2) mat2 {
	var m mat2
	for i := range a {
		for j := range a[i] {
			m[i][j] = a[i][j] + b[i][j]
		}
	}
	return m
}

func sub2(a, b mat2) mat2 {
	var m mat2
	for i := range a {
		for j := range a[i] {
			m[i][j] = a[i][j] - b[i][j]
		}
	}
	return m
}

func mul2(a, b mat2) mat2 {
	var m mat2
	for i := range a {
		for j := range a[i] {
			for k := range a[j] {
				m[i][j] += a[i][k] * b[k][j]
			}
		}
	}
	return m
}

func det2(m mat2) float64 {
	return m[0][0]*m[1][1] - m[0][1]*m[1][0]
}

func inv2(m mat2) mat2 {
	d := det2(m)
	if d != 0 {
		d = 1 / d
	}

	var p mat2
	p[0][0] = m[1][1] * d
	p[0][1] = -m[0][1] * d
	p[1][0] = -m[1][0] * d
	p[1][1] = m[0][0] * d
	return p
}

func transpose2(m mat2) mat2 {
	var p mat2
	for i := range m {
		for j := range m[i] {
			p[i][j] = m[j][i]
		}
	}
	return p
}

func adj2(m mat2) mat2 {
	return mat2{
		{m[1][1], -m[0][1]},
		{-m[1][0], m[0][0]},
	}
}
