// ported from http://dev.theomader.com/gaussian-kernel-calculator/
// gaussian blur filter matrices found online do a rounding step
// they do this by dividing
// the smallest coefficient to make them all multiples of the smallest
// coefficient, round to nearest integer, then normalize that
package main

import (
	"flag"
	"fmt"
	"log"
	"math"
)

var (
	sigma  = flag.Float64("s", 1.4, "sigma factor")
	kernsz = flag.Int("k", 5, "kernel size")
	dim    = flag.Int("d", 2, "sample in n dimension")
	count  = flag.Int("c", 100000, "number of samples")
	nonorm = flag.Bool("nd", false, "don't normalize")
	digits = flag.Int("si", 6, "round to number of significant digits")
)

func main() {
	flag.Parse()

	switch *dim {
	case 1:
		c := kernel(*sigma, *kernsz, *count, !*nonorm)
		for i := range c {
			fmt.Printf("%.*f ", *digits, c[i].w)
		}
		fmt.Println()
	case 2:
		c := kernel2(*sigma, *kernsz, *count, !*nonorm)
		for i := range c {
			for j := range c[i] {
				fmt.Printf("%.*f ", *digits, c[i][j].w)
			}
			fmt.Println()
		}
	default:
		log.Fatalf("%d dimension not supported", *dim)
	}
}

// gaussian distribution centered around mu (mean) with stddev sigma
func gauss(x, mu, sigma float64) float64 {
	d := x - mu
	n := 1 / (math.Sqrt(2*math.Pi) * sigma)
	return n * math.Exp(-(d*d)/(2*sigma*sigma))
}

// sample [start, end] in an evenly spaced manner with count samples
func sample(f func(x float64) float64, start, end float64, count int) [][2]float64 {
	r := make([][2]float64, count)
	s := (end - start) / float64(count-1)
	for i := 0; i < count; i++ {
		x := start + float64(i)*s
		y := f(x)
		r[i] = [2]float64{x, y}
	}
	return r
}

// simpson integration
func simpson(samples [][2]float64) float64 {
	n := len(samples) - 1
	r := samples[0][1] + samples[n][1]
	for i := 1; i < len(samples)-1; i++ {
		w := 2.0
		if i%2 != 0 {
			w = 4
		}
		r += w * samples[i][1]
	}
	h := (samples[n][0] - samples[0][0]) / float64(n)
	return r * h / 3
}

type coeff struct {
	s [][2]float64
	w float64
}

type coeff2 struct {
	x, y coeff
	w    float64
}

// generate 1d kernel coefficients with kernel support window of 'size'
// with number of count samples
func kernel(sigma float64, size, count int, normalize bool) []coeff {
	// divide the number of samples into evenly spaced bins
	// each of those bins will constitute the range for one kernel coefficient
	spb := int(math.Ceil(float64(count) / float64(size)))
	// need it to be odd number of sample for simpson integration
	if spb%2 == 0 {
		spb++
	}

	f := func(start, end float64) [][2]float64 {
		return sample(func(x float64) float64 {
			return gauss(x, 0, sigma)
		}, start, end, spb)
	}

	// each coefficient is generated by numerically integrating
	// around the integer coordinate as the center
	// for example for a 5 coefficients, go from
	// integrate from [-2.5, -1.5], [-1.5, 0.5] and so on
	var c []coeff
	o := -math.Floor(float64(size) / 2)
	w := 0.0
	for i := 0; i < size; i++ {
		l := o - 0.5 + float64(i)
		r := l + 1
		s := f(l, r)
		t := simpson(s)

		c = append(c, coeff{s, t})
		w += t
	}

	if normalize {
		for i := range c {
			c[i].w /= w
		}
	}
	return c
}

// since we want to sample in a square, and gaussians are symmetric (circular)
// we can use 1d coefficients and combine them to get
// the 2d coefficient
func kernel2(sigma float64, size, count int, normalize bool) [][]coeff2 {
	var p [][]coeff2

	c := kernel(sigma, size, count, normalize)
	for i := range c {
		var q []coeff2
		for j := range c {
			q = append(q, coeff2{c[j], c[i], c[i].w * c[j].w})
		}
		p = append(p, q)
	}
	return p
}
