/*

https://www.newport.com/c/plano-convex-lenses
https://www.thorlabs.com/navigation.cfm?guide_ID=100
https://wp.optics.arizona.edu/optomech/wp-content/uploads/sites/53/2016/12/Tutorial_Ruiz_Maria.pdf

*/

package main

import (
	"flag"
	"fmt"
	"math"
	"os"
)

var opt struct {
	n         float64
	radius    float64
	thickness float64
	dz        float64
	aperture  float64
	rays      float64
	width     int
	height    int
	outfile   string
}

func main() {
	parse_flags()

	// field of view, the area where light rays will pass through
	// larger field of view means smaller increments so more sampling resolution
	dy := (2*opt.aperture + 1) / opt.rays
	var y []float64
	for i := -opt.aperture; i <= opt.aperture; i += dy {
		y = append(y, i)
	}

	// send light rays through the field of view and see how it refracts
	// based on the physical parameters we specified
	raymatrix, x_front, x_optaxis, _ := plano_convex(opt.n, opt.radius, opt.thickness, opt.dz, y)

	ray_focus := make([]int, len(y))
	for i := range ray_focus {
		m := math.MaxFloat32
		for j := range raymatrix[i] {
			if n := math.Abs(raymatrix[i][j]); m > n {
				ray_focus[i] = j
				m = n
			}
		}
	}
	paraxial_focus := ray_focus[len(y)/2]

	var front_lens []float64
	front_lens_max := -math.MaxFloat32
	for i := range x_front {
		front_lens = append(front_lens, math.Sqrt(opt.radius*opt.radius-(x_front[i]-opt.radius)*(x_front[i]-opt.radius)))
		front_lens_max = math.Max(front_lens_max, front_lens[len(front_lens)-1])
	}

	var spher_ab []float64
	for i := range y {
		if y[i] >= 0 {
			spher_ab = append(spher_ab, x_optaxis[ray_focus[i]])
		}
	}

	w := os.Stdout
	fmt.Fprintf(w, "# Autogenerated gnuplot script\n")
	fmt.Fprintf(w, "# refractive_index=%.6f radius=%.6f thickness=%.6f steps=%.6f aperture %.6f number_of_rays=%.6f\n",
		opt.n, opt.radius, opt.thickness, opt.dz, opt.aperture, opt.rays)
	fmt.Fprintf(w, "set term png size %d, %d\n", opt.width, opt.height)
	fmt.Fprintf(w, "set output \"%s\"\n", opt.outfile)
	fmt.Fprintf(w, "set style line 1 lt rgb \"#0072BD\" lw 3 pt 6\n")
	fmt.Fprintf(w, "set style line 2 lt rgb \"red\" lw 1 pt 1\n")
	fmt.Fprintf(w, "set style line 3 lt rgb \"black\" lw 3\n")
	fmt.Fprintf(w, "set multiplot layout 3, 1 title \"Plano Convex Lens\"\n")

	fmt.Fprintf(w, "set title \"Refractions\"\n")
	fmt.Fprintf(w, "array x_front[%d]\n", len(x_front))
	fmt.Fprintf(w, "array p_frontlens[%d]\n", len(x_front))
	fmt.Fprintf(w, "array n_frontlens[%d]\n", len(x_front))

	fmt.Fprintf(w, "array x_optaxis[%d]\n", len(x_optaxis))
	fmt.Fprintf(w, "array x_optaxis_zero[%d]\n", len(x_optaxis))
	for i := range raymatrix {
		fmt.Fprintf(w, "array raymatrix_%d[%d]\n", i+1, len(x_optaxis))
	}

	fmt.Fprintf(w, "array front_lens_vline_x[%d]\n", 2)
	fmt.Fprintf(w, "array front_lens_vline_y[%d]\n", 2)

	for i := 0; i < 2; i++ {
		fmt.Fprintf(w, "front_lens_vline_x[%d] = %.6f\n", i+1, opt.thickness)
	}
	fmt.Fprintf(w, "front_lens_vline_y[%d] = %.6f\n", 1, front_lens_max)
	fmt.Fprintf(w, "front_lens_vline_y[%d] = %.6f\n", 2, -front_lens_max)

	for i := range x_front {
		fmt.Fprintf(w, "x_front[%d] = %.6f; ", i+1, x_front[i])
		fmt.Fprintf(w, "p_frontlens[%d] = %.6f; ", i+1, front_lens[i])
		fmt.Fprintf(w, "n_frontlens[%d] = %.6f; ", i+1, -front_lens[i])
		fmt.Fprintf(w, "\n")
	}

	for i := range x_optaxis {
		fmt.Fprintf(w, "x_optaxis[%d] = %.6f; ", i+1, x_optaxis[i])
		fmt.Fprintf(w, "x_optaxis_zero[%d] = %.6f; ", i+1, 0.0)
		for j := range y {
			fmt.Fprintf(w, "raymatrix_%d[%d] = %.6f; ", j+1, i+1, raymatrix[j][i])
		}
		fmt.Fprintf(w, "\n")
	}

	cmd := fmt.Sprintf("plot sample ")
	for i := range y {
		cmd += fmt.Sprintf("[i=1:%d] '+' using (x_optaxis[i]):(raymatrix_%d[i]) with lines ls 2 notitle, ", len(x_optaxis), i+1)
	}
	cmd += fmt.Sprintf("[i=1:%d] '+' using (x_front[i]):(p_frontlens[i]) with lines ls 1 notitle, ", len(x_front))
	cmd += fmt.Sprintf("[i=1:%d] '+' using (x_front[i]):(n_frontlens[i]) with lines ls 1 notitle, ", len(x_front))
	cmd += fmt.Sprintf("[i=1:%d] '+' using (x_optaxis[i]):(x_optaxis_zero[i]) with lines ls 3 notitle, ", len(x_optaxis))
	cmd += fmt.Sprintf("[i=1:%d] '+' using (front_lens_vline_x[i]):(front_lens_vline_y[i]) with lines ls 1 notitle, ", 2)
	fmt.Fprintf(w, "%s\n", cmd)

	fmt.Fprintf(w, "\n")
	fmt.Fprintf(w, "set title \"Ray Fan Plot\"\n")
	fmt.Fprintf(w, "array rf_x[%d]\n", len(y))
	fmt.Fprintf(w, "array rf_y[%d]\n", len(y))
	for i := range y {
		fmt.Fprintf(w, "rf_x[%d] = %v\n", i+1, y[i])
	}
	for i := range y {
		fmt.Fprintf(w, "rf_y[%d] = %.6f\n", i+1, raymatrix[i][paraxial_focus])
	}
	fmt.Fprintf(w, "plot sample [i=1:%d] '+' using (rf_x[i]):(rf_y[i]) with linespoints ls 1 title \"%s\"\n",
		len(y), "Paraxial Focus")
	fmt.Fprintf(w, "\n")

	fmt.Fprintf(w, "set title \"Spherical Aberration\"\n")
	fmt.Fprintf(w, "array sa_x[%d]\n", len(spher_ab))
	fmt.Fprintf(w, "array sa_y[%d]\n", len(spher_ab))
	for i := range spher_ab {
		fmt.Fprintf(w, "sa_x[%d] = %.6f\n", i+1, spher_ab[i]-spher_ab[0])
	}
	j := 0
	for i := range y {
		if y[i] >= 0 {
			fmt.Fprintf(w, "sa_y[%d] = %v\n", j+1, y[i])
			j++
		}
	}
	fmt.Fprintf(w, "plot sample [i=1:%d] '+' using (sa_x[i]):(sa_y[i]) with linespoints ls 1 title \"%s\"\n",
		len(spher_ab), "Aberation")
	fmt.Fprintf(w, "\n")
}

func parse_flags() {
	flag.Float64Var(&opt.n, "n", 1.5168, "index of refraction of lens")
	flag.Float64Var(&opt.radius, "radius", 20, "radius of spherical surface")
	flag.Float64Var(&opt.thickness, "thickness", 2, "central thickness of lens")
	flag.Float64Var(&opt.dz, "dz", 0.01, "step size")
	flag.Float64Var(&opt.aperture, "aperture", 5, "aperture")
	flag.Float64Var(&opt.rays, "rays", 11, "number of rays")
	flag.IntVar(&opt.width, "width", 2048, "output image width")
	flag.IntVar(&opt.height, "height", 2048, "output image height")
	flag.Parse()

	opt.outfile = "plano_convex_lens.png"
	if flag.NArg() > 0 {
		opt.outfile = flag.Arg(0)
	}
}

func sphere_refract_ray(y float64, radius, thickness, n, dz float64) (ray []float64, slope float64, z []float64) {
	sag := radius - math.Sqrt(radius*radius-y*y)
	for i := sag; i <= thickness; i += dz {
		z = append(z, i)
	}
	sin_phi1 := y / radius
	sin_phi2 := sin_phi1 / n
	phi1 := math.Asin(sin_phi1)
	phi2 := math.Asin(sin_phi2)
	theta := phi2 - phi1
	slope = math.Tan(theta)
	for i := range z {
		ray = append(ray, slope*(z[i]-sag)+y)
	}
	return
}

func plane_refract_ray(y, slope, thickness, n float64, z []float64) (ray_air []float64) {
	theta1 := math.Atan(slope)
	theta2 := math.Asin(n * math.Sin(theta1))
	slope2 := math.Tan(theta2)
	for i := range z {
		ray_air = append(ray_air, (z[i]-thickness)*slope2+y)
	}
	return
}

func plano_convex(n, radius, thickness, dz float64, y []float64) (raymatrix [][]float64, z_front, z_optaxis []float64, z_max float64) {
	power := (n - 1) / radius
	f := 1.0 / power
	z_max = math.Floor(f + 0.1*f)

	var z_back []float64
	for z := 0.0; z < thickness; z += dz {
		z_front = append(z_front, z)
	}
	for z := thickness; z < z_max; z += dz {
		z_back = append(z_back, z)
	}
	z_optaxis = append(z_optaxis, z_front...)
	z_optaxis = append(z_optaxis, z_back...)

	y = append([]float64{}, y...)
	for i := range y {
		if y[i] == 0 {
			y[i] = 1e-10
		}
	}

	raymatrix = make([][]float64, len(y))
	for i := range y {
		ray_lens, slope, x_lens := sphere_refract_ray(y[i], radius, thickness, n, dz)
		ray_air := plane_refract_ray(ray_lens[len(ray_lens)-1], slope, thickness, n, z_back)

		var x_front_air, ray_front_air []float64
		for z := 0.0; z <= x_lens[0]-dz; z += dz {
			x_front_air = append(x_front_air, z)
		}
		for range x_front_air {
			ray_front_air = append(ray_front_air, y[i])
		}

		raymatrix[i] = append(raymatrix[i], ray_front_air...)
		raymatrix[i] = append(raymatrix[i], ray_lens...)
		raymatrix[i] = append(raymatrix[i], ray_air...)
	}

	return
}
