/*

http://sites.science.oregonstate.edu/~landaur/Books/CPbook/index.html

*/

package main

import (
	"bufio"
	"flag"
	"fmt"
	"math"
	"os"
)

type option struct {
	L       float64
	s       float64
	n       int
	v0      float64
	w, h    int
	outfile string
}

var opt option

func main() {
	parseflags()
	output(&opt)
}

func parseflags() {
	flag.Float64Var(&opt.L, "L", 50, "grid boundary")
	flag.Float64Var(&opt.s, "s", 0.1, "step size")
	flag.IntVar(&opt.n, "n", 20, "number of terms")
	flag.Float64Var(&opt.v0, "v0", 100, "initial voltage")
	flag.IntVar(&opt.w, "w", 2048, "image width")
	flag.IntVar(&opt.h, "h", 2048, "image height")
	flag.StringVar(&opt.outfile, "o", "1d_electric_potential.png", "output file")
	flag.Parse()
}

func output(o *option) {
	w := bufio.NewWriter(os.Stdout)
	defer w.Flush()
	fmt.Fprintf(w, "# Autogenerated gnuplot script\n")
	fmt.Fprintf(w, "# boundary=%.6f step=%.6f term=%d initial_voltage=%.6f\n", o.L, o.s, o.n, o.v0)
	fmt.Fprintf(w, "set term png size %d, %d\n", o.w, o.h)
	fmt.Fprintf(w, "set output \"%s\"\n", o.outfile)

	fmt.Fprintf(w, "splot '-'\n")
	for y := 0.0; y <= o.L; y += o.s {
		for x := 0.0; x <= o.L; x += o.s {
			fmt.Fprintf(w, "%.6f %.6f %.6f\n", x, y, potential(o.L, o.v0, x, y, o.n))
		}
	}
	fmt.Fprintf(w, "e\n")
}

/*

We have a 2D square grid of a constant voltage line connected to ground, want to find
the voltage potential at every point V(x, y).

*/

func potential(L, v0, x, y float64, n int) float64 {
	r := 0.0
	for i := 1; i <= n; i += 2 {
		j := float64(i)
		a := 4.0 * v0 / (j * math.Pi)
		b := math.Sin(j * math.Pi * x / L)
		c := math.Sinh(j*math.Pi*y/L) / math.Sinh(j*math.Pi)
		r += a * b * c
	}
	return r
}
